<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	<binding id="conceptTree"
		extends="chrome://semantic-turkey/content/widget/taxonomyTree/impl/taxonomyTree.xml#taxonomyTree">
		<handlers>
			<handler event="it.uniroma2.art.semanticturkey.event.widget.tree.dblclick">
			<![CDATA[
			if (event.detail.rowIndex == -1) return;
			
			if (!this.mutable) return;
			
			var parameters = {
				sourceElement : null,		// elemento contenente i dati della riga corrente
				sourceType : "concept",		// tipo di editor: clss, ..., determina le funzioni custom ed il titolo della finestra
				sourceElementName : this.selectedConcept,	// nome dell'elemento corrente (quello usato per identificazione: attualmente il qname)
				sourceParentElementName : "", // nome dell'elemento genitore
				isFirstEditor : true,		 // l'editor Ã¨ stato aperto direttamente dall class/... tree o da un altro editor?
				deleteForbidden : false, 	 // cancellazione vietata 
				parentWindow : window,		 // finestra da cui viene aperto l'editor
				skos : {selectedScheme : this.conceptScheme}
			};
			art_semanticturkey.ResourceViewLauncher.openResourceView(parameters);
			]]>
			</handler>
		</handlers>
		<implementation>
			<constructor>
			<![CDATA[
				if (typeof this.art_semanticturkey == "undefined") {
					this.art_semanticturkey= {};
				}

				Components.utils.import("resource://stmodules/Logger.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/stEvtMgr.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/Commands.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/Context.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stservices/SERVICE_SKOS.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stservices/SERVICE_OntoSearch.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/PrefUtils.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/Preferences.jsm", this.art_semanticturkey);				
				Components.utils.import("resource://stmodules/ARTResources.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/ResourceViewLauncher.jsm", art_semanticturkey);			
				
				var mozIJSSubScriptLoader = Components.classes["@mozilla.org/moz/jssubscript-loader;1"]
				                                      .getService(Components.interfaces.mozIJSSubScriptLoader);
                mozIJSSubScriptLoader.loadSubScript("chrome://semantic-turkey/content/event/eventObjects.js", this);
                
                //mozIJSSubScriptLoader.loadSubScript("chrome://semantic-turkey/content/utilities/deserializer.js?timestamp="+((new Date()).getTime()), this);
				
				
				var bound = this;
				
				function DataRow(record) {
					this.__defineGetter__("id", function(){return this.record.concept;});
					this.__defineSetter__("id", function(v){this.record.concept = v;});
					this.record = record;
					
					this.isContainer = true;
					this.isContainerEmpty = record.more != "1";
					
					this.level = 0;
					this.isContainerOpen = false;
					this.cache = {};
					
					this.matches = function(id) {
						return this.id == id || this.record.uri == id;
					};
				}
				
				this._view.sourceAdapter.fetchRoots = function() {						
						var deserializedResponse = null;
						try{
							var language = null;
							if (isHumanReadable) {
								language = bound.art_semanticturkey.Preferences.get("extensions.semturkey.annotprops.defaultlang" ,"en");
							}
							
							if (typeof bound.projectName != "undefined"){
								bound.art_semanticturkey.Logger.debug("PROJECT NAME " + bound.projectName);
								var specifiedContext = new bound.art_semanticturkey.Context();
								specifiedContext.setProject(bound.projectName);
								var serviceInstance = bound.art_semanticturkey.STRequests.SKOS.getAPI(specifiedContext);
								deserializedResponse=serviceInstance.getTopConcepts(bound.conceptScheme == "*" ? null : bound.conceptScheme, language);
							} else {
								deserializedResponse=bound.art_semanticturkey.STRequests.SKOS.getTopConcepts(bound.conceptScheme == "*" ? null : bound.conceptScheme, language);
							}
						}catch (e) {
							return [];
						}
						
						return parseResponse(deserializedResponse);
				};
					
				this._view.sourceAdapter.fetchChildren = function(id){
						var deserializedResponse = null;
						try{
							var language = null;
							if (isHumanReadable) {
								language = bound.art_semanticturkey.Preferences.get("extensions.semturkey.annotprops.defaultlang" ,"en");
							}
							
							if (typeof bound.projectName != "undefined"){
								bound.art_semanticturkey.Logger.debug("PROJECT NAME " + bound.projectName);
								var specifiedContext = new bound.art_semanticturkey.Context();
								specifiedContext.setProject(bound.projectName);
								var serviceInstance = bound.art_semanticturkey.STRequests.SKOS.getAPI(specifiedContext);
								deserializedResponse=serviceInstance.getNarrowerConcepts(id, bound.conceptScheme == "*" ? null : bound.conceptScheme, language);
							} else {
								deserializedResponse=bound.art_semanticturkey.STRequests.SKOS.getNarrowerConcepts(id, bound.conceptScheme == "*" ? null : bound.conceptScheme, language);
							}
						}catch (e) {
							return [];
						}
						return parseResponse(deserializedResponse);
				};
					
				var parseResponse = function(collectionValues) {
					var result = [];
					
					//var collectionValues = art_semanticturkey.deserializer.createRDFArray(responseElement);
					for (var i = 0; i < collectionValues.length; ++i) {
						var uriElem = collectionValues[i];
						
						//item = new DataRow({concept : conceptList[i].getAttribute("name"), 
					    //                                                        more : conceptList[i].getAttribute("more"),
					    //                                                        label : conceptList[i].getAttribute("label"),
					    //                                                        uri : conceptList[i].getAttribute("uri")							
					    //                                                        }); 
						var item = new DataRow({concept : uriElem.getURI(), 
                                            more : uriElem.more,
                                            label : uriElem.getShow(),
                                            uri : uriElem.getURI()							
                                             }); 
						
						result.push(item);						
					}
					
					
					return result;
				};
				
				this._view.provider.getLabel = function(row, col) {
					if (col.id != "concept") {
						return this._view.__proto__.getLabel(row, col);
					}
					
//					if (isHumanReadable) {
//						if (row.record["label"].trim() != "") {
//							return row.record["label"];
//						}
//					}								
//					
//					return row.record["concept"];

					return row.record["label"].trim();
				};
						
				this._view.provider.getImageURL = function(row, col) {
						return "chrome://semantic-turkey/skin/images/skosConcept.png";
				};

/*				
				this._view.addLabelDecorator({getDecoratedLabel : function(label, row, col) {
					return label + "(" + row.record.numInst + ")";
				}});
*/

		/*		
				this._view.addImageDecorator(new function(){
					this.getDecoratedImage = function(imageURL, row, col) {
			
						if (!foo) {
							return;
						}
			
						var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");				

						canvas.width = 16;
						canvas.height = 16;
						var context = canvas.getContext("2d");

						context.drawImage(img, 0, 0);
						
						context.fillStyle = "black";
						context.textBaseline = "top";
						context.fillText("C", 0, 0);						
						
						var url = canvas.toDataURL("image/png");
						
						return url;
					};	
				});
*/

				this.columns = "concept";
				
				var ctxMenu = document.getAnonymousElementByAttribute(this, "ano_id", "ctx");
				var taxonomyToolbar = document.getAnonymousElementByAttribute(this, "ano_id", "taxonomyToolbar");

				this.stEventArray = new this.art_semanticturkey.eventListenerArrayClass();
				
				function skosConceptRemovedHandler(eventId, eventObj) {
					bound._view.removeRows(eventObj.getConceptName());
				}
				
				this.stEventArray.addEventListenerToArrayAndRegister("skosConceptRemoved", skosConceptRemovedHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlConceptRemoved", skosConceptRemovedHandler, null);
				
				function skosConceptAddedHandler(eventId, eventObj) {
					var narrowerConcept = eventObj.getConcept();
					var broaderConcept = eventObj.getBroaderConceptName();
					var u = narrowerConcept.getURI();
					var hasSubsumees = narrowerConcept.more;
					var l = narrowerConcept.getShow();

					var row = new DataRow({concept : u, more : hasSubsumees, label : l, uri : u});

					bound._view.addRow(broaderConcept, row);
				}
				
				this.stEventArray.addEventListenerToArrayAndRegister("skosConceptAdded", skosConceptAddedHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlConceptAdded", skosConceptAddedHandler, null);
				
				function skosBroaderConceptAddedHandler(eventId, eventObj) {
					var aConcept = eventObj.getConcept();
					var narrowerConcept = aConcept.getURI();
					var broaderConcept = eventObj.getBroaderConceptName();
					var u = aConcept.getURI();
					var hasSubsumees = aConcept.more;
					var l = aConcept.getShow();
								
					var row = new DataRow({concept : narrowerConcept, more : hasSubsumees, label : l, uri : u});
					
					bound._view.addRow(broaderConcept, row);
					
					/*
					 * A concept is no more a top concept of a scheme, if it is added below a concept belonging to that
					 * scheme. Unfortunately, we haven't an adequate event mechanism yet.  However, we can safely assume
					 * that the conept belongs to the current scheme, because the editor let us modify only a concept scheme
					 */  
					var topNoMore = true;
					
					if (topNoMore) {
						bound._view.removeRows(narrowerConcept, 0);					
					}
				}
				
				this.stEventArray.addEventListenerToArrayAndRegister("skosBroaderConceptAdded",skosBroaderConceptAddedHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlBroaderConceptAdded",skosBroaderConceptAddedHandler, null);
				
				function skosBroaderConceptRemovedHandler(eventId, eventObj) {
					var conceptName = eventObj.getConceptName();
					var broaderConceptName = eventObj.getBroaderConceptName();
					bound._view.removeRows(conceptName, broaderConceptName);
				}
				
				this.stEventArray.addEventListenerToArrayAndRegister("skosBroaderConceptRemoved", skosBroaderConceptRemovedHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlBroaderConceptRemoved", skosBroaderConceptRemovedHandler, null);
				
				function skosTopConceptAddedHandler(eventId, eventObj) {
					if (eventObj.getSchemeName() != bound.conceptScheme) {
						return;
					}
					
					var topConcept = eventObj.getTopConcept();
					var concept = topConcept.getURI();
					var u = topConcept.getURI();
					var hs = topConcept.more;
					var l = topConcept.getShow();
								
					var row = new DataRow({concept : concept, more : hs, label : l, uri : u});
					
					bound._view.addRow(null, row);				
				}
				
				this.stEventArray.addEventListenerToArrayAndRegister("skosTopConceptAdded", skosTopConceptAddedHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlTopConceptAdded", skosTopConceptAddedHandler, null);
				
				function skosTopConceptRemovedHandler(eventId, eventObj) {
					if (eventObj.getSchemeName() != bound.conceptScheme) {
						return;
					}
					
					var concept = eventObj.getConceptName();

					bound._view.removeRows(concept, 0);
				}
				
				this.stEventArray.addEventListenerToArrayAndRegister("skosTopConceptRemoved", skosTopConceptRemovedHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlTopConceptRemoved", skosTopConceptRemovedHandler, null);

				this.stEventArray.addEventListenerToArrayAndRegister("resourceRenamed", function(eventId, resourceRenamedObj) {
					
					if (resourceRenamedObj.getOldName() === bound.conceptScheme) {
						// Assigns the new name to the private attribute, to prevent the widget from reloading
						bound._conceptScheme = resourceRenamedObj.getNewName();
						return;
					}
					
					var newLabel = null;
					
					if (!isHumanReadable) {
						try {
							newLabel = bound.art_semanticturkey.STRequests.SKOS.getShow(resourceRenamedObj.getNewName());
						} catch(e) {
							alert(e);
						}
					}
					
					for (var i = 0 ; i < bound._view.visibleRows2.length ; i++) {					
						if (bound._view.visibleRows2[i].id == resourceRenamedObj.getOldName()) {
							bound._view.visibleRows2[i].id = resourceRenamedObj.getNewName();
							
							if (newLabel != null) {
								bound._view.visibleRows2[i].record["label"] = newLabel;
							}
							
							bound._view.invalidateRow(i);
						}
					}
				}, null);
				
				function skosPrefLabelSetHandler(eventId, eventObj) {
					if (!isHumanReadable) return;
										
					if (eventObj.getLang() != bound.art_semanticturkey.Preferences.get("extensions.semturkey.annotprops.defaultlang" ,"en")) {
						return;
					}
					
					for (var i = 0 ; i < bound._view.visibleRows2.length ; i++) {
						if (bound._view.visibleRows2[i].id == eventObj.getConceptName()) {
							bound._view.visibleRows2[i].record["label"] = eventObj.getLabel();
							bound._view.invalidateRow(i);
						}
					}				
				}
				
				this.stEventArray.addEventListenerToArrayAndRegister("skosPrefLabelSet", skosPrefLabelSetHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlPrefLabelSet", skosPrefLabelSetHandler, null);
			
				function skosPrefLabelRemovedHandler(eventId, eventObj) {
					if (eventObj.getLang() != bound.art_semanticturkey.Preferences.get("extensions.semturkey.annotprops.defaultlang" ,"en")) {
						return;
					}
										
					if (!isHumanReadable) return;
					
					var newLabel = "";
					
					try {
						newLabel = bound.art_semanticturkey.STRequests.SKOS.getShow(eventObj.getConceptName());
					} catch(e) {
						alert(e);
					}
					
					for (var i = 0 ; i < bound._view.visibleRows2.length ; i++) {
						if (bound._view.visibleRows2[i].id == eventObj.getConceptName()) {
							bound._view.visibleRows2[i].record["label"] = newLabel;
							bound._view.invalidateRow(i);
						}
					}
				}
				
				this.stEventArray.addEventListenerToArrayAndRegister("skosPrefLabelRemoved", skosPrefLabelRemovedHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlPrefLabelRemoved", skosPrefLabelRemovedHandler, null);

				function skosSchemeRemovedHandler(eventId, eventObj) {
					if (eventObj.getSchemeName() == bound.conceptScheme) {
						bound.conceptScheme = "";
					}
				}
				this.stEventArray.addEventListenerToArrayAndRegister("skosSchemeRemoved", skosSchemeRemovedHandler, null);
				this.stEventArray.addEventListenerToArrayAndRegister("skosxlSchemeRemoved", skosSchemeRemovedHandler, null);
				
				function skosConceptRemovedFromSchemeHandler(eventId, eventObj) {
					// Ignore this event, since it affects a different concept scheme then the one
					// associated with this concept tree
					if (bound.conceptScheme != eventObj.getSchemeName()) return;					
					
					bound._view.removeRows(eventObj.getConceptName());
				}
				this.stEventArray.addEventListenerToArrayAndRegister("skosConceptRemovedFromScheme", skosConceptRemovedFromSchemeHandler, null);

				function skosConceptAddedToSchemeHandler(eventId, eventObj) {
					try {
						// Ignore this event, since it affects a different concept scheme then the one
						// associated with this concept tree
						if (bound.conceptScheme != eventObj.getSchemeName()) return;					
											
						var insertionPoints = [];
						eventObj.getInsertionPoints().forEach(function(el){return insertionPoints.push(el.getNominalValue());});
						var addedConcept = eventObj.getAddedConcept();
						
						var u = addedConcept.getURI();
						var hs = addedConcept.more;
						var l = addedConcept.getShow();
									
						alert(hs ? "1" : "0");
						var row = new DataRow({concept : u, more : hs, label : l, uri : u});
						
						bound._view.addRow(insertionPoints, row);						
						
					} catch(e) {
						alert(e);
					}
				}
				this.stEventArray.addEventListenerToArrayAndRegister("skosConceptAddedToScheme", skosConceptAddedToSchemeHandler, null);

				this.ctxMenuTracker = new this.art_semanticturkey.MenuPopupTrackerAdapter("skos:concept*edit", this, ctxMenu);
				this.art_semanticturkey.CommandBroker.registerTracker(this.ctxMenuTracker);
				
				this.toolbarTracker = new this.art_semanticturkey.ToolbarTrackerAdapter("skos:concept*edit", this, taxonomyToolbar, true);
				this.art_semanticturkey.CommandBroker.registerTracker(this.toolbarTracker);
				
				this.projectType = "^.*SKOS.*$";
				
				var isHumanReadable	= false;
				
				var setHumanReadable = function(flag) {
					isHumanReadable = flag;
					
					bound._view.reload();
				};
				
				this.prefListener = new this.art_semanticturkey.PrefListener("extensions.semturkey.", function(branch, name){
					if (name == "skos.humanReadable") {
						var isReadable = branch.getBoolPref(name);
						
						setHumanReadable(isReadable);
						//bound._view.reload();						
					} else if (name == "annotprops.defaultlang") {
						bound._view.reload();
					}
				});
				this.prefListener.register(true);
				
				bound._powerManager = function(state) {
					if (state.indexOf("project") != -1 && state.indexOf("conceptSchemeSelected") != -1) {
						bound._view.powerOn();
					} else {
						bound._view.powerOff();
					}
				};
			]]>
			</constructor>
			<destructor>
				this.stEventArray.deregisterAllListener();
				
				if (typeof this.ctxMenuTracker != "undefined") {
					this.art_semanticturkey.CommandBroker.unregisterTracker(this.ctxMenuTracker);
				}
				
				if (typeof this.toolbarTracker != "undefined") {
					this.art_semanticturkey.CommandBroker.unregisterTracker(this.toolbarTracker);
				}
				
				this.prefListener.unregister();
			</destructor>
			<property name="selectedConcept">
				<getter>
					var taxonomyTree =
					document.getAnonymousElementByAttribute(this, "ano_id",
					"taxonomyTree");

					if (taxonomyTree.currentIndex == -1) return null;

					var row = this._view.getRow(taxonomyTree.currentIndex);

					return row.id;
				</getter>
			</property>
			<property name="conceptScheme">
				<getter>
					return this._conceptScheme;
				</getter>
				<setter>
					if (typeof this._conceptScheme == "undefined" || this._conceptScheme != val) {
						this._conceptScheme = val;
	
						if (val != "") {
							if (this._view.isPowered()) {
								this._view.reload();
							}
							
							if (val == "*") {
								this._onStateChanged("mutable!");
							} else {
								this._onStateChanged("mutable");
							}
							
							this._onStateChanged("conceptSchemeSelected");
						} else {
							this._view.powerOff();
							this._onStateChanged("conceptSchemeSelected!");
						}
					}
				</setter>
			</property>
			<method name="focusOnConcept">
				<parameter name="concUri"/>
				<parameter name="schemeName"/>
				<body>
				<![CDATA[
					var tree = document.getAnonymousElementByAttribute(this, "ano_id", "taxonomyTree");
					var rowCount = tree.view.rowCount;
					indexOfRes = -1;
					for (var i=0; i<rowCount; i++){
						var row = this._view.getRow(i);
						if (row.id == concUri){
							indexOfRes = i;
							break;
						}
					}
					if (indexOfRes != -1){ //concept found in visible tree
						//Logger.debug(concUri + " found at index " + indexOfRes);
						tree.boxObject.ensureRowIsVisible(indexOfRes);
						tree.view.selection.select(indexOfRes);
					} else { //concept NOT found in visible tree
						//get the path from root to concept 
						var xmlResp = this.art_semanticturkey.STRequests.OntoSearch.getPathFromRoot(concUri, schemeName);
						var path = xmlResp.getElementsByTagName("concept");
						//Logger.debug("looking for " + concUri);
						for (i=0; i<path.length; i++){
							var pathElemUri = path[i].textContent;
							for (var j=0; j<rowCount; j++){
								var row = this._view.getRow(j);
								if (row.id == concUri) {
									//Logger.debug("searched concept " + concUri + " found, selecting");
									tree.view.selection.select(j);
									return;
								} else if (row.id == pathElemUri){
									//Logger.debug(pathElemUri + " found at level " + row.level + ". Opening");
									if (!this._view.getRow(j).isContainerOpen){//open row only if is close
										this._view.toggleOpenState(j);
										rowCount = tree.view.rowCount;//update rowCount that change after open/close a row
									}
								}
							}
						}
					}
				]]>
				</body>
			</method> 
		</implementation>
	</binding>
</bindings>