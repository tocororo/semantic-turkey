<?xml version="1.0"?>
<?xml-stylesheet href="chrome://semantic-turkey/content/class/class.css" type="text/css"?>
<bindings xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	<binding id="tree-widget">
		<content>
			<!-- <xul:popupset>
				<xul:menupopup anonid="clipmenuTree" align="start">
				</xul:menupopup>
			</xul:popupset> -->
		
			<xul:tree hidecolumnpicker="true" anonid="mainTree" seltype="single" flex="2"
				 rows="5" context="_child">
				<xul:treecols anonid="treecolsId">
					 <xul:treecol anonid="treecolId" primary="true" flex="1" />
				</xul:treecols>
				<xul:treechildren anonid="rootClassTreeChildren" flex="1"/>
				<!-- Since the context of the tree element is set to _child, its context menu must be 
				placed inside the tree itself -->
				<xul:menupopup anonid="clipmenuTree" align="start"/>
			</xul:tree>
			<!-- The structure of a tree is: 
				tree 
					treecols 
						treecol 
					treechildren 
						treeitem 
							treerow 
								treecell 
						treeitem 
							treerow 
								treecell 
							treechildren 
								treeitem 
									treerow 
										treecell 
								treeitem 
									treerow 
										treecell -->

		</content>
		<implementation>
			<field name="treecolLabel" />
			<constructor>
				<![CDATA[
					if (typeof art_semanticturkey == 'undefined')
						var art_semanticturkey = {};
					Components.utils.import("resource://stmodules/StResUtils.jsm", art_semanticturkey);
					Components.utils.import("resource://stmodules/ARTResources.jsm", art_semanticturkey);
					Components.utils.import("resource://stmodules/Logger.jsm", art_semanticturkey);

					if(typeof this.treecolLabel != "undefined"){
						this.setTitle(treecolLabel);	
					}
				]]>
			</constructor>

			<method name="setTitle">
				<parameter name="title"/>
				<body>
					<![CDATA[
						var treecol = document.getAnonymousElementByAttribute(this, "anonid", "treecolId");
						treecol.setAttribute("label", title);
					]]>
				</body>
			</method>

			<method name="clearTree">
				<body>
					<![CDATA[
						var rootClassTreeChildren = document.getAnonymousElementByAttribute(this, "anonid", 
							"rootClassTreeChildren");
						while(rootClassTreeChildren.childNodes.length > 0)
							rootClassTreeChildren.removeChild(rootClassTreeChildren.childNodes[0]);
					]]>
				</body>
			</method>

			<method name="setRowsNumber">
				<parameter name="value"/>
				<body>
					<![CDATA[
						document.getAnonymousElementByAttribute(this, "anonid", "mainTree")
							.setAttribute("rows", value);
					]]>
				</body>
			</method>

			<method name="getSelectedRDFNode">
				<body>
					<![CDATA[
					var tree = document.getAnonymousElementByAttribute(this, "anonid", "mainTree");
					var range = tree.view.selection.getRangeCount();
					if (range <= 0) {
						return;
					}
					var currentelement = tree.treeBoxObject.view.getItemAtIndex(tree.currentIndex);
					var treerow = currentelement.getElementsByTagName('treerow')[0];
					var treecell = treerow.getElementsByTagName('treecell')[0];
					var rdfNode = treecell.rdfNode;
					return rdfNode;
					]]>
				</body>
			</method>
			
			<method name="addToContextMenu">
				<parameter name="menutimeAnonId" />
				<parameter name="labelValue" />
				<parameter name="imageSrc" />
				<parameter name="associatedFunction" />
				<body>
					<![CDATA[
						var contextMenu = 
							document.getAnonymousElementByAttribute(this, "anonid", "clipmenuTree");
							
						var mi = document.createElement("menuitem");
						mi.setAttribute("flex", "1");
						mi.setAttribute("anonid", menutimeAnonId);
						mi.addEventListener("command",associatedFunction, true);
						
						mi.widgetTree = this; 	// add the the menuitem the widgetTree. this is useful when
												// dealing with the associated event
						
						var mii = document.createElement("menuitem-iconic");
						mii.setAttribute("flex", "1");
						var image = document.createElement("image");
						if(typeof imageSrc != 'undefined')
							image.setAttribute("src", imageSrc);
						else
							image.setAttribute("src", "chrome://semantic-turkey/skin/images/empty20x20.png");
						image.setAttribute("flex", "0");
						var label = document.createElement("label");
						label.setAttribute("value", labelValue);
						label.setAttribute("flex", "0");
						mii.appendChild(image);
						mii.appendChild(label);
						mi.appendChild(mii);
						contextMenu.appendChild(mi);
						
					]]>
				</body>
			</method>
			
			<method name="getParentRDFNodeFromSelectedRDFNode">
				<body>
					<![CDATA[
					var tree = document.getAnonymousElementByAttribute(this, "anonid", "mainTree");
					var range = tree.view.selection.getRangeCount();
					if (range <= 0) {
						return;
					}
					var currentelement = tree.treeBoxObject.view.getItemAtIndex(tree.currentIndex);
					
					var parentTreeiterm = currentelement.parentNode.parentNode;
					
					var treerow = parentTreeiterm.getElementsByTagName('treerow')[0];
					if(typeof treerow == "undefined")
						return;
					var treecell = treerow.getElementsByTagName('treecell')[0];
					var rdfNode = treecell.rdfNode;
					return rdfNode;
					]]>
				</body>
			</method>

			<method name="addRoot">
				<parameter name="newRoot" />
				<parameter name="hasChild" />
				<body>
					<![CDATA[
					if(typeof newRoot != "undefined"){
					
						//create a treeitem
						var ti = document.createElement("treeitem");
						
						this.addValueInTreeItemsetValuesInTreeCell(ti, newRoot, hasChild);
						
						
						//now append all the elements to each other
						document.getAnonymousElementByAttribute(this, "anonid", "rootClassTreeChildren")
							.appendChild(ti);
						
					}				
					]]>
				</body>
			</method>
			
			<method name="addChild">
				<parameter name="parentRDFNode" />
				<parameter name="childRDFNode" />
				<parameter name="hasChild" />
				<body>
					<![CDATA[
					//iterate over all the opened element in the tree to search for the one with the right
					// id (partentID)
					var rootClassTreeChildren = document
							.getAnonymousElementByAttribute(this, "anonid", "rootClassTreeChildren");
					
					var treeCellArray = this.searchForRDFNode(parentRDFNode);
					
					var partentID = this.getIdFromRDFNode(parentRDFNode);
					
					for(var i=0; i<treeCellArray.length; ++i){
						var singleTreeCell = treeCellArray[i];
						var singleTreeItem = singleTreeCell.parentNode.parentNode;
						if(singleTreeItem.getAttribute("container") != "true" || 
							typeof singleTreeItem.getElementsByTagName("treechildren")[0] == 'undefined'){
								singleTreeItem.setAttribute("container", "true");
								treechildren = document.createElement("treechildren");
								singleTreeItem.appendChild(treechildren);
						}
						treechildren = singleTreeItem.getElementsByTagName("treechildren")[0];
						treechildren.getElementsByTagName("treechildren")[0];
						var newTreeitem = document.createElement("treeitem");
						singleTreeItem.setAttribute("open", true);
						this.addValueInTreeItemsetValuesInTreeCell(newTreeitem, childRDFNode, hasChild);
							treechildren.appendChild(newTreeitem);
					}
					]]>
				</body>
			</method>
			
			
			
			<method name="removeChild">
				<parameter name="selRDFNode" />
				<parameter name="force" />
				<parameter name="parentRDFNode" />
				<body>
					<![CDATA[
						var result = false;
						if(typeof force == "undefined")
							force = false;
							
						//if the parent is specified, search for the parent and removed the desired selRDFNode
						var parentNodeId;
						if(typeof parentRDFNode != "undefined"){
							parentNodeId = this.getIdFromRDFNode(parentRDFNode);
						}
						
						//get all the Treecell containing the desired RDFNode  
						var treecellToDeleteArray = this.searchForRDFNode(selRDFNode);
						for(var i=0; i<treecellToDeleteArray.length; ++i){
							var treecell = treecellToDeleteArray[i];
							var treechildren = treecell.parentNode.parentNode.parentNode;
							var isRoot = false;
							if(treechildren.parentNode.tagName == "xul:tree"){ // it is a root node
								isRoot = true;
								//TODO decide what to do with this information
							} 
							//check if parentRDFNode is set and if so if it is the right one
							if(typeof parentNodeId != 'undefined'){
								//the parentNode is set, so check if the current one is the right one
								var currentParentTreecell = treechildren.parentNode.childNodes[0].childNodes[0];
								var currentParentIDRDFnode = this.getIdFromRDFNode(currentParentTreecell.rdfNode);
								if(currentParentIDRDFnode != parentNodeId)
									continue;
							}
							
							//check if the current treecell (the one obtained from selRDFNode) has child 
							//and if force was set to true
							
							var currentChildNumber = treecell.parentNode.parentNode.childNodes.length;
							
							if(currentChildNumber==2 && 
									treecell.parentNode.parentNode.childNodes[1].childNodes.length > 0 &&
									(force == false || force == 'false' )){
								// you cannot remove the current node, it has at least one child and 
								// force was set to false
								continue;
							}
							
							// the current element has no child or the force was set to true, so 
							// it can be remove
							
							var currentTreeitem = treecell.parentNode.parentNode; 
							var parentTreechildren = currentTreeitem.parentNode;
							
							parentTreechildren.removeChild(currentTreeitem);
							
							//check if the parent (parentTreechildren) had just the removed child or not
							var numberParentChild = parentTreechildren.childNodes.length;
							if(numberParentChild == 0){
								//the parent has no more child, so its treechildren shuold be deleted,
								// and its treeitem should have containet set to false
								var parentTreeitem = parentTreechildren.parentNode;
								parentTreeitem.removeChild(parentTreechildren);
								parentTreeitem.setAttribute("container", false);
							}
								
						}
						
						
						return result;
					]]>
				</body>
			</method>
			<method name="changeChild">
				<parameter name="oldChild" />
				<parameter name="newChild" />
				<body>
					<![CDATA[
						if(typeof oldChild == 'undefined' || typeof newChild == 'undefined')
							return;
						var oldTreeCellArray = this.searchForRDFNode(oldChild);
						for(var i=0; i<oldTreeCellArray.length; ++i){
							oldTreeCellArray[i].rdfNode = newChild;
							var label = this.getShow(newChild);
							oldTreeCellArray[i].setAttribute("label", label);
						}
					]]>
				</body>
			</method>
			
			
			<!-- These methods should be called just from the other methods and not from the outside -->
			<method name="addValueInTreeItemsetValuesInTreeCell">
				<parameter name="ti"/>
				<parameter name="rdfNode"/>
				<parameter name="hasChild"/>
				<body>
					<![CDATA[
						//create a treerow
						var tr = document.createElement("treerow");
						//create a treecell (the treecell is what is visible with its label)
						var tc = document.createElement("treecell");
					
						tc.rdfNode = rdfNode;
						//decide what to show and what to set as its id
						var label = this.getShow(rdfNode);
						
						/*if(rdfNode.getShow != undefined){ // ARTURIResource
							label = rdfNode.getShow();
						} else if (rdfNode.getId != undefined){ // ARTBNode
							label = newRoot.getId(); 
						} else if(rdfNode.getLabel != undefined){
							label = rdfNode.getLabel();
							if(rdfNode.getLang != undefined && rdfNode.getLang() != ""){
								label += "@"+rdfNode.getLang();
							}
						} else{ // it should never enter here
							return;
						}*/
						tc.setAttribute("label", label);
						
						//check if hasChild is set and if it is set to true
						if(typeof hasChild != "undefined" && hasChild == true){
							ti.setAttribute("container", true);
						} else{
							ti.setAttribute("container", false);
						}
						
						tr.appendChild(tc);
						ti.appendChild(tr);
						
					]]>
				</body>
			</method>
			<method name="getShow">
				<parameter name="rdfNode"/>
				<body>
					<![CDATA[
						var show;
						if(rdfNode.getShow != undefined){ // ARTURIResource
							show = rdfNode.getShow();
						} else if (rdfNode.getId != undefined){ // ARTBNode
							show = newRoot.getId(); 
						} else if(rdfNode.getLabel != undefined){
							show = rdfNode.getLabel();
							if(rdfNode.getLang != undefined && rdfNode.getLang() != ""){
								show += "@"+rdfNode.getLang();
							}
						} else{ // it should never enter here
							return;
						}
						return show;
					]]>
				</body>
			</method>
			<method name="getIdFromRDFNode">
				<parameter name="rdfNode" />
				<body>
					<![CDATA[
						if(typeof rdfNode == "undefined")
							return "";
						var id;
						if(rdfNode.getURI != undefined){ // ARTURIResource
							id = rdfNode.getURI();
						} else if (rdfNode.getId != undefined){ // ARTBNode
							id = rdfNode.getId(); 
						} else if(rdfNode.getLabel != undefined){
							id = rdfNode.getLabel();
							if(rdfNode.getLang != undefined && rdfNode.getLang() != ""){
								id += "@"+rdfNode.getLang();
							} else if(rdfNode.getDatatype!= undefined && rdfNode.getDatatype() != ""){
								id += "^^<"+rdfNode.getDatatype()+">";
							}
						} else{ // it should never enter here
							return "";
						}
						return id;
					]]>
				</body>
			</method>
			
			<method name="searchForRDFNode">
				<parameter name="selRDFNode" />
				<body>
					<![CDATA[
					var resultTreeCellArray = new Array();
					if(typeof selRDFNode == "undefined")
						return resultTreeCellArray; 
					var selIdRDFNode =  this.getIdFromRDFNode(selRDFNode);
					var rootClassTreeChildren = document
						.getAnonymousElementByAttribute(this, "anonid", "rootClassTreeChildren");
					var treeCellArray = rootClassTreeChildren.getElementsByTagName("treecell");
					for(var i=0; i<treeCellArray.length; ++i){
						//for each treecell take the store rdfNode and confront its id with the input one
						var singleTreeCell = treeCellArray[i]
						var currentRDFNodeOfTreeCell = singleTreeCell.rdfNode;
						idRDFNode = this.getIdFromRDFNode(currentRDFNodeOfTreeCell);
						if(selIdRDFNode == idRDFNode){
							resultTreeCellArray[resultTreeCellArray.length] = singleTreeCell;
						}
					}
					return resultTreeCellArray;
					]]>
				</body>
			</method>
			
			<method name="clikOrKeyPress">
				<parameter name="event"/>
				<body>
					<![CDATA[
						var tree = document.getAnonymousElementByAttribute(this, "anonid", "mainTree");
						var action;
						var treeitem;
						
						action = "infoOnRDFNode"; // default action
						if (event.type == "keypress") {
							var keyCode = event.keyCode;
							treeitem = tree.treeBoxObject.view.getItemAtIndex(tree.currentIndex);
							var isContainer = treeitem.getAttribute("container");
							if (isContainer == "false") {
								//return;
							}
							var isOpen = treeitem.getAttribute("open");
							if (keyCode == KeyEvent.DOM_VK_RETURN) {
								if (isOpen == "true") {
									action = "openSubTree";
								} else if (isOpen == "false") {
									action = "closeSubTree";
								}
							} else if ((keyCode == KeyEvent.DOM_VK_RIGHT) && (isOpen == "true")) {
								action = "openSubTree";
							} else if ((keyCode == KeyEvent.DOM_VK_LEFT) && (isOpen == "false")) {
								action = "closeSubTree";
							} else {
								//return;
							}
						} else if (event.type == "click") {
							var row = {};
							var col = {};
							var part = {};
							tree.treeBoxObject.getCellAt(event.clientX, event.clientY, row, col, part);
							treeitem = tree.contentView.getItemAtIndex(row.value);
							var isContainer = treeitem.getAttribute("container");
							if (isContainer == "false") {
								//return;
							} else{
								var isTwisty = (part.value == "twisty");
								if (isTwisty == false) {
									// the user did not click on the twisty, so he does not want the sub
									// classes
									//return;
								} else {
									var isOpen = treeitem.getAttribute("open");
									if (isOpen == "true") {
										//action = "closeSubTree";
										action = "openSubTree";
									} else if (isOpen == "false") {
										//action = "openSubTree";
										action = "closeSubTree";
									}
								}
							}
						} else { // this should never happen
							return
						}
						
						//decide which event to throw depending on th value of action
						
						var eventName = action+"Event";
						
						//stop the event propagation to not generate confusion
						//event.stopPropagation();
					
						var customEvent = new CustomEvent(eventName, {
							detail: {
								rdfNode: treeitem.childNodes[0].childNodes[0].rdfNode,
								ti: treeitem
							},
							bubble: true,
							cancellable: true
						})
						tree.dispatchEvent(customEvent);
					]]>
				</body>
			</method>
			
			<method name="dblclick">
				<parameter name="event"/>
				<body>
					<![CDATA[
						var tree = document.getAnonymousElementByAttribute(this, "anonid", "mainTree");
						var treeitem;
						
						var row = {};
						var col = {};
						var part = {};
						tree.treeBoxObject.getCellAt(event.clientX, event.clientY, row, col, part);
						treeitem = tree.contentView.getItemAtIndex(row.value);
						
						//stop the event propagation to not generate confusion
						event.stopPropagation();
					
						var customEvent = new CustomEvent("dblclickOnTree", {
							detail: {
								rdfNode: treeitem.childNodes[0].childNodes[0].rdfNode,
								ti: treeitem
							},
							bubble: true,
							cancellable: true
						})
						tree.dispatchEvent(customEvent);
					]]>
				</body>
			</method>
		</implementation>
		
		<!-- EVENTS  -->
		<handlers>
			<handler event="dblclick">
				<![CDATA[
					//alert("dblclick");
					//event.preventDefault();
    				//event.stopPropagation();
    				this.dblclick(event);
	     		]]>
			</handler>
			<handler event="click">
				<![CDATA[
					//alert("click e event = "+event);
					this.clikOrKeyPress(event);
					
					
	     		]]>
			</handler>
			<handler event="keypress">
				<![CDATA[
					//alert("keypress e event = "+event);
					this.clikOrKeyPress(event);
				]]>
			</handler>
			
			
					
		</handlers>
	</binding>
</bindings>