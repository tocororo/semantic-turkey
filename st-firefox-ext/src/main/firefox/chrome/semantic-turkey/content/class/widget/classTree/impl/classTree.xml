<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	<binding id="classTree"
		extends="chrome://semantic-turkey/content/widget/taxonomyTree/impl/taxonomyTree.xml#taxonomyTree">
		<handlers>
			<handler event="it.uniroma2.art.semanticturkey.event.widget.tree.dblclick">
			<![CDATA[
			if (event.detail.rowIndex == -1) return;
			
			if (!this.mutable) return;
			
			var parameters = {
				sourceElement : null,		// elemento contenente i dati della riga corrente
				sourceType : "concept",		// tipo di editor: clss, ..., determina le funzioni custom ed il titolo della finestra
				sourceElementName : this.selectedConcept,	// nome dell'elemento corrente (quello usato per identificazione: attualmente il qname)
				sourceParentElementName : "", // nome dell'elemento genitore
				isFirstEditor : true,		 // l'editor Ã¨ stato aperto direttamente dall class/... tree o da un altro editor?
				deleteForbidden : false, 	 // cancellazione vietata 
				parentWindow : window,		 // finestra da cui viene aperto l'editor
				skos : {selectedScheme : this.conceptScheme}
			};
			art_semanticturkey.ResourceViewLauncher.openResourceView(parameters);
			]]>
			</handler>
		</handlers>
		<implementation>
			<constructor>
			<![CDATA[
				if (typeof this.art_semanticturkey == "undefined") {
					this.art_semanticturkey= {};
				}

				Components.utils.import("resource://stmodules/Logger.jsm");
				Components.utils.import("resource://stmodules/stEvtMgr.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/Commands.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/Context.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stservices/SERVICE_OntoSearch.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stservices/SERVICE_Cls.jsm", art_semanticturkey);
				Components.utils.import("resource://stmodules/PrefUtils.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/Preferences.jsm", this.art_semanticturkey);				
				Components.utils.import("resource://stmodules/ARTResources.jsm", this.art_semanticturkey);
				Components.utils.import("resource://stmodules/ResourceViewLauncher.jsm", art_semanticturkey);
				Components.utils.import("resource://stmodules/StResUtils.jsm", art_semanticturkey);		
				
				var mozIJSSubScriptLoader = Components.classes["@mozilla.org/moz/jssubscript-loader;1"]
				                                      .getService(Components.interfaces.mozIJSSubScriptLoader);
                mozIJSSubScriptLoader.loadSubScript("chrome://semantic-turkey/content/event/eventObjects.js", this);
                
                //mozIJSSubScriptLoader.loadSubScript("chrome://semantic-turkey/content/utilities/deserializer.js?timestamp="+((new Date()).getTime()), this);
                
				var bound = this;
				
				function DataRow(record) {
					this.__defineGetter__("id", function(){return this.record.concept;});
					this.__defineSetter__("id", function(v){this.record.concept = v;});
					this.record = record;
					
					this.isContainer = true;
					this.isContainerEmpty = record.more != "1";
					
					this.level = 0;
					this.isContainerOpen = false;
					this.cache = {};
					
					this.matches = function(id) {
						return this.id == id || this.record.uri == id;
					};
				}
				
				this._view.sourceAdapter.fetchRoots = function() {						
						var deserializedResponse = null;
						try{
							var language = null;
							if (isHumanReadable) {
								language = bound.art_semanticturkey.Preferences.get("extensions.semturkey.annotprops.defaultlang" ,"en");
							}
							if (typeof bound.projectName != "undefined"){
								//create a context for a project different from the current and get owl:Thing info
								var specifiedContext = new bound.art_semanticturkey.Context();
								specifiedContext.setProject(bound.projectName);
								var serviceInstance = bound.art_semanticturkey.STRequests.Cls.getAPI(specifiedContext);
								deserializedResponse=serviceInstance.getClassesInfoAsRootsForTree(true, "http://www.w3.org/2002/07/owl#Thing");
							} else {
								deserializedResponse=bound.art_semanticturkey.STRequests.Cls.getClassesInfoAsRootsForTree(true, "http://www.w3.org/2002/07/owl#Thing");
							}
						}catch (e) {
							return [];
						}
						
						return parseResponse(deserializedResponse);
				};
					
				this._view.sourceAdapter.fetchChildren = function(id){
						var deserializedResponse = null;
						try{
							var language = null;
							if (isHumanReadable) {
								language = bound.art_semanticturkey.Preferences.get("extensions.semturkey.annotprops.defaultlang" ,"en");
							}
							
							if (typeof bound.projectName != "undefined"){
								//create a context for a project different from the current and get the subclasses of owl:Thing
								var specifiedContext = new bound.art_semanticturkey.Context();
								specifiedContext.setProject(bound.projectName);
								var serviceInstance = bound.art_semanticturkey.STRequests.Cls.getAPI(specifiedContext);
								deserializedResponse=serviceInstance.getSubClasses(id, true, true);
							} else {
								deserializedResponse = bound.art_semanticturkey.STRequests.Cls.getSubClasses(id, true, true);
							}
						}catch (e) {
							return [];
						}
						return parseResponse(deserializedResponse);
				};
					
				var parseResponse = function(collectionValues) {
					var result = [];
					
					for (var i = 0; i < collectionValues.length; ++i) {
						var uriElem = collectionValues[i];
						
						var item = new DataRow({concept : uriElem.getURI(), 
                                            more : uriElem.more,
                                            label : uriElem.getShow(),
                                            uri : uriElem.getURI(),
                                            explicit: uriElem.explicit,
                                            role: uriElem.getRole(),
                                            numInst: uriElem.numInst,	
                                            }); 
                        item.imageUrl = bound.art_semanticturkey.STResUtils.getImageSrcOrNull(uriElem);
						result.push(item);						
					}
					
					
					return result;
				};
				
				this._view.provider.getLabel = function(row, col) {
					if (col.id != "concept") {
						return this._view.__proto__.getLabel(row, col);
					}
					
					return row.record["label"].trim();
				};
						
				this._view.provider.getImageURL = function(row, col) {
					return row.imageUrl;
				};

				this.columns = "concept";
				
				this.stEventArray = new this.art_semanticturkey.eventListenerArrayClass();
				
				
				this.projectType = "^.*$";
				
				var isHumanReadable	= false;
				
				var setHumanReadable = function(flag) {
					isHumanReadable = flag;
					
					bound._view.reload();
				};
				
				this.prefListener = new this.art_semanticturkey.PrefListener("extensions.semturkey.", function(branch, name){
					if (name == "skos.humanReadable") {
						var isReadable = branch.getBoolPref(name);
						
						setHumanReadable(isReadable);
						//bound._view.reload();						
					} else if (name == "annotprops.defaultlang") {
						bound._view.reload();
					}
				});
				this.prefListener.register(true);
				
				bound._powerManager = function(state) {
					//commented because when browing project different from the current one
					//it invokes powerOff and the concept tree is closed
					/* 
					if (state.indexOf("project") != -1) {
						bound._view.powerOn();
					} else {
						bound._view.powerOff();
					}
					*/
				};
			]]>
			</constructor>
			<destructor>
				this.stEventArray.deregisterAllListener();
				
				this.prefListener.unregister();
			</destructor>
			<property name="selectedClass">
				<getter>
					var taxonomyTree =
					document.getAnonymousElementByAttribute(this, "ano_id",	"taxonomyTree");

					if (taxonomyTree.currentIndex == -1) return null;

					var row = this._view.getRow(taxonomyTree.currentIndex);

					return row.id;
				</getter>
			</property>
		</implementation>
	</binding>
</bindings>