package it.uniroma2.art.semanticturkey.services.core;

import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.servlet.ServletRequest;

import it.uniroma2.art.coda.core.CODACore;
import it.uniroma2.art.coda.exception.ConverterException;
import it.uniroma2.art.coda.exception.DependencyException;
import it.uniroma2.art.coda.exception.PRParserException;
import it.uniroma2.art.coda.provisioning.ComponentProvisioningException;
import it.uniroma2.art.coda.structures.ARTTriple;
import it.uniroma2.art.owlart.exceptions.ModelAccessException;
import it.uniroma2.art.owlart.exceptions.ModelUpdateException;
import it.uniroma2.art.owlart.exceptions.QueryEvaluationException;
import it.uniroma2.art.owlart.exceptions.UnavailableResourceException;
import it.uniroma2.art.owlart.exceptions.UnsupportedQueryLanguageException;
import it.uniroma2.art.owlart.model.ARTNode;
import it.uniroma2.art.owlart.model.ARTResource;
import it.uniroma2.art.owlart.model.ARTURIResource;
import it.uniroma2.art.owlart.model.NodeFilters;
import it.uniroma2.art.owlart.models.ModelFactory;
import it.uniroma2.art.owlart.models.RDFModel;
import it.uniroma2.art.owlart.models.conf.ModelConfiguration;
import it.uniroma2.art.owlart.query.MalformedQueryException;
import it.uniroma2.art.semanticturkey.customrange.CustomRangeCODAManager;
import it.uniroma2.art.semanticturkey.customrange.CustomRangeEntry;
import it.uniroma2.art.semanticturkey.customrange.UserPromptStruct;
import it.uniroma2.art.semanticturkey.exceptions.CODAException;
import it.uniroma2.art.semanticturkey.exceptions.ProjectInconsistentException;
import it.uniroma2.art.semanticturkey.generation.annotation.GenerateSTServiceController;
import it.uniroma2.art.semanticturkey.plugin.PluginManager;
import it.uniroma2.art.semanticturkey.services.STServiceAdapter;
import it.uniroma2.art.semanticturkey.services.annotations.Optional;
import it.uniroma2.art.semanticturkey.servlet.Response;
import it.uniroma2.art.semanticturkey.servlet.XMLResponseREPLY;
import it.uniroma2.art.semanticturkey.servlet.ServiceVocabulary.RepliesStatus;
import it.uniroma2.art.semanticturkey.utilities.XMLHelp;

import org.apache.uima.UIMAException;
import org.springframework.beans.factory.ObjectFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;
import org.w3c.dom.Element;

@GenerateSTServiceController
@Validated
@Component
public class CODA extends STServiceAdapter {
	
	@Autowired
	private ObjectFactory<CustomRangeCODAManager> crCODAMgrProvider;
	
	@Autowired
	private ServletRequest request;
	
	/**
	 * This service get as parameters a custom range id and a set of userPrompt key-value pairs
	 * (userPrompt are unknown a priori, so pairs are dynamic and have to be get from the request
	 * TODO: find a better solution), then run CODA on the pearl specified in the CustomRangeEntry
	 * (with the given id <code>crEntryId</code>) and the features filled following the userPrompt parameters.
	 * Finally, "append" the triples generated by CODA to the subject-property pair
	 *  
	 * @param crEntryId
	 * @return
	 * @throws FileNotFoundException 
	 * @throws CODAException 
	 * @throws ProjectInconsistentException 
	 * @throws UnavailableResourceException 
	 * @throws ModelUpdateException 
	 */
	@GenerateSTServiceController
	public Response runCoda(ARTResource subject, ARTURIResource predicate, String crEntryId) throws FileNotFoundException, CODAException, 
			UnavailableResourceException, ProjectInconsistentException, ModelUpdateException {
		//get the parameters to put in the userPromptMap from the request
		Map<String, String[]> parMap = request.getParameterMap();//the others params (form key and values) are dynamic, get it directly from request
		Map<String, String> userPromptMap = new HashMap<String, String>();
		for (Entry<String, String[]> par : parMap.entrySet()){
//			System.out.println("param: " + par.getKey() + ", value: " + par.getValue()[0]);
			userPromptMap.put(par.getKey(), par.getValue()[0]);
		}
		//Remove useless parameters for fillMapAndAddTriples method (parameters not belonging to userPrompt feature)
		/* N.B. if some other parameters will be put in this map, there should be no problem since
		 * when this map will be used to valorize the CAS, the value will be get based on the feature 
		 * in the TSD and the unnecessary params will be simply ignored */
		userPromptMap.remove("ctx_project");
		userPromptMap.remove("crEntryId");
		userPromptMap.remove("subject");
		userPromptMap.remove("predicate");
		for (Entry<String, String> e : userPromptMap.entrySet()){
			System.out.println("userPrompt: " + e.getKey() + " = " + e.getValue());
		}
		try {
			CustomRangeCODAManager crCodaMgr = crCODAMgrProvider.getObject();
			ModelFactory<ModelConfiguration> ontFact = PluginManager.getOntManagerImpl(getProject().getOntologyManagerImplID()).createModelFactory();
			RDFModel rdfModel = getOWLModel();
			CustomRangeEntry crEntry = new CustomRangeEntry(crEntryId);
			if (crEntry.isTypeGraph()){
				List<ARTTriple> triples = crCodaMgr.executeCREntryPearl(rdfModel, ontFact, userPromptMap, crEntry);
//				System.out.println("S:\t"+subject.getNominalValue()+"\nP:\t"+predicate.getNominalValue()+"\nO:\t"+triples.get(0).getSubject().getNominalValue());
				rdfModel.addTriple(subject, predicate, detectGraphEntry(triples), NodeFilters.MAINGRAPH);
				for (ARTTriple triple : triples){
//					System.out.println("S:\t"+triple.getSubject()+"\nP:\t"+triple.getPredicate()+"\nO:\t"+triple.getObject());
					rdfModel.addTriple(triple.getSubject(), triple.getPredicate(), triple.getObject(), NodeFilters.MAINGRAPH);
				}
			} else if (crEntry.isTypeNode()){
				UserPromptStruct upStruct = crCodaMgr.getForm(rdfModel, ontFact, crEntry).get(0);//if type=node, it's sure that there is only 1 form entry
				CODACore codaCore = crCodaMgr.getCODACore();
				codaCore.initialize(rdfModel, ontFact);
				String value = userPromptMap.entrySet().iterator().next().getValue();//get the only value
				ARTNode artNode;
				if (upStruct.isLiteral()){
					artNode = codaCore.executeLiteralConverter(
							upStruct.getConverter(), value, upStruct.getLiteralDatatype(), upStruct.getLiteralLang());
				} else {//type "uri"
					artNode = codaCore.executeURIConverter(upStruct.getConverter(), value);
				}
				System.out.println("Adding triple:\nS:\t"+subject.getNominalValue()+"\nP:\t"+predicate.getNominalValue()+"\nO:\t"+artNode.getNominalValue());
				rdfModel.addTriple(subject, predicate, artNode, NodeFilters.MAINGRAPH);
			}
		} catch (UIMAException | PRParserException | ComponentProvisioningException | ConverterException | 
				UnsupportedQueryLanguageException | ModelAccessException | MalformedQueryException | 
				QueryEvaluationException | DependencyException e){
			throw new CODAException(e);
		}
		XMLResponseREPLY response = createReplyResponse(RepliesStatus.ok);
		return response;
	}
	
	/**
	 * This method detects the entry of a graph (list of triples) based on an heuristic: entry is that subject that never appears as object
	 * @param triples
	 * @return
	 */
	private ARTResource detectGraphEntry(List<ARTTriple> triples){
		for (ARTTriple t1 : triples){
			ARTResource subj = t1.getSubject();
			boolean neverObj = true;
			for (ARTTriple t2 : triples){
				if (subj.getNominalValue().equals(t2.getObject().getNominalValue()))
					neverObj = false;
			}
			if (neverObj)
				return subj;
		}
		return null;
	}
	
	@GenerateSTServiceController
	public Response executeURIConverter(String converter, @Optional String value) throws ComponentProvisioningException, 
			ConverterException, UnavailableResourceException, ProjectInconsistentException {
		String result = "";
		CODACore codaCore = crCODAMgrProvider.getObject().getCODACore();
		ModelFactory<ModelConfiguration> ontFact = PluginManager.getOntManagerImpl(getProject().getOntologyManagerImplID()).createModelFactory();
		codaCore.initialize(getOWLModel(), ontFact);
		if (value != null){
			result = codaCore.executeURIConverter(converter, value).getNominalValue();
		} else {
			result = codaCore.executeURIConverter(converter).getNominalValue();
		}
		XMLResponseREPLY response = createReplyResponse(RepliesStatus.ok);
		Element dataElement = response.getDataElement();
		Element valueElement = XMLHelp.newElement(dataElement, "value");
		valueElement.setAttribute("converter", converter);
		valueElement.setTextContent(result);
		return response;
	}
	
	@GenerateSTServiceController
	public Response executeLiteralConverter(String converter, String value, @Optional String datatype, @Optional String lang) 
			throws ComponentProvisioningException, ConverterException, UnavailableResourceException, ProjectInconsistentException {
		CODACore codaCore = crCODAMgrProvider.getObject().getCODACore();
		ModelFactory<ModelConfiguration> ontFact = PluginManager.getOntManagerImpl(getProject().getOntologyManagerImplID()).createModelFactory();
		codaCore.initialize(getOWLModel(), ontFact);
		String result = codaCore.executeLiteralConverter(converter, value, datatype, lang).getNominalValue();
		XMLResponseREPLY response = createReplyResponse(RepliesStatus.ok);
		Element dataElement = response.getDataElement();
		Element valueElement = XMLHelp.newElement(dataElement, "value");
		valueElement.setAttribute("converter", converter);
		valueElement.setTextContent(result);
		return response;
	}
	
//	@GenerateSTServiceController
//	public Response test(Map<String, String> map, String crEntryId){
//		for (Entry<String, String> e : map.entrySet()){
//			System.out.println(e.getKey() + ", " + e.getValue());
//		}		
//		XMLResponseREPLY response = ServletUtilities.getService().createReplyResponse("test",RepliesStatus.ok);
//		return response;
//	}

}
